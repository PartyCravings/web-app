#!/usr/bin/env php
<?php
use AppBundle\Utils\Server;
use AppBundle\Utils\StrongerNativeSessionStorage;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\StreamedResponse as SymfonyStreamedResponse;
use Psr\Http\Message\ServerRequestInterface;
use RingCentral\Psr7;
use React\EventLoop\Factory;
use React\Http\Response;

require __DIR__.'/../vendor/autoload.php';
// if you don't want to setup permissions the proper way, just uncomment the following PHP line
// read https://symfony.com/doc/current/setup.html#checking-symfony-application-configuration-and-setup
// for more information
//umask(0000);
set_time_limit(0);
$kernel = new AppKernel('dev', false);
// When using the HttpCache, you need to call the method in your front controller instead of relying on the configuration parameter
Request::enableHttpMethodParameterOverride();
Request::setTrustedProxies(
    // the IP address (or range) of your proxy
    ['127.0.0.1', '10.0.0.0/8'],
    // trust *all* "X-Forwarded-*" headers
    Request::HEADER_X_FORWARDED_ALL
    // or, if your proxy instead uses the "Forwarded" header
    // Request::HEADER_FORWARDED
    // or, if you're using AWS ELB
    // Request::HEADER_X_FORWARDED_AWS_ELB
);
Server::bindAndCall(function() use ($kernel) {
        // init bundles
        $kernel->initializeBundles();
        // init container
        $kernel->initializeContainer();
    }, $kernel);
//now we can modify the container
$nativeStorage = new StrongerNativeSessionStorage(
        $kernel->getContainer()->getParameter('session.storage.options'),
        $kernel->getContainer()->has('session.handler') ? $kernel->getContainer()->get('session.handler'): null,
        $kernel->getContainer()->get('session.storage.metadata_bag')
    );
$kernel->getContainer()->set('session.storage.native', $nativeStorage);
Server::bindAndCall(function() use ($kernel) {
        foreach ($kernel->getBundles() as $bundle) {
                $bundle->setContainer($kernel->container);
                $bundle->boot();
            }
            $kernel->booted = true;
        }, $kernel);
$kernel = new AppCache($kernel);
$callback = function (ServerRequestInterface $request) use ($kernel) {
    $mem_usage = memory_get_peak_usage(true)/(1024*1024);
    if (55 <= $mem_usage) {
        die('MAX MEMORY EXCEEDED');
    }
    $method = $request->getMethod();
    $headers = $request->getHeaders();
    $_COOKIE = $request->getCookieParams();
    $content = $request->getParsedBody();
    $server = $request->getServerParams();
    $server['REQUEST_URI'] = (string)$request->getUri();
    $_POST =(array)$content;
    $_GET = $request->getQueryParams();
    $_FILES = $request->getUploadedFiles();

    $_SERVER = array_merge($_SERVER, $server);

    $session_set = false;
    foreach ($_COOKIE as $name => $value) {
        if ($name === session_name()) {
            session_id($value);
            $session_set = true;
        }
    }
    if (!$session_set && session_id()) {
        // session id already set from the last round but not obtained
        // from the cookie header, so generate a new one, since php is
        // not doing it automatically with session_start() if session
        // has already been started.
        session_start();
        session_id(Server::generateSessionId());
    }
    $request = new Request(
        $_GET,
        $_POST,
        $request->getAttributes(),
        $_COOKIE,
        $_FILES,
        $_SERVER,
        $content
    );    
    $request->setMethod($method);
    $request->headers->replace($headers);
    $response = $kernel->handle($request);
     // end active session
    if (PHP_SESSION_ACTIVE === session_status()) {
        session_write_close();
        session_unset(); // reset $_SESSION
    }
    $headers = ['X-Powered-By'=> 'Terminator/Genisys'];
    foreach (headers_list() as $header) {
        if (false !== $pos = strpos($header, ':')) {
            $name = substr($header, 0, $pos);
            $value = trim(substr($header, $pos + 1));
            if (isset($headers[$name])) {
                if (!is_array($headers[$name])) {
                    $headers[$name] = [$headers[$name]];
                }
                $headers[$name][] = $value;
            } else {
                $headers[$name] = $value;
            }
        }
    }
    // after reading all headers we need to reset it, so next request
    // operates on a clean header.
    header_remove();
    $headers = array_merge($headers, $response->headers->allPreserveCase());

    $cookies = [];
    /** @var Cookie $cookie */
        foreach ($response->headers->getCookies() as $cookie) {
            $cookieHeader = sprintf('%s=%s', $cookie->getName(), $cookie->getValue());

            if ($cookie->getPath()) {
                $cookieHeader .= '; Path=' . $cookie->getPath();
            }
            if ($cookie->getDomain()) {
                $cookieHeader .= '; Domain=' . $cookie->getDomain();
            }

            if ($cookie->getExpiresTime()) {
                $cookieHeader .= '; Expires=' . gmdate('D, d-M-Y H:i:s', $cookie->getExpiresTime()). ' GMT';
            }

            if ($cookie->isSecure()) {
                $cookieHeader .= '; Secure';
            }
            if ($cookie->isHttpOnly()) {
                $cookieHeader .= '; HttpOnly';
            }

            $cookies[] = $cookieHeader;
        }

        if (isset($headers['Set-Cookie'])) {
            $headers['Set-Cookie'] = array_merge((array)$headers['Set-Cookie'], $cookies);
        } else {
            $headers['Set-Cookie'] = $cookies;
        }

        $psrResponse = new Psr7\Response($response->getStatusCode(), $headers);

        // get contents
        ob_start();
        if ($response instanceof SymfonyStreamedResponse) {
            $response->sendContent();
            $content = @ob_get_clean();
        }
        else {
            ob_start();
            $content = $response->getContent();
            @ob_end_flush();
        }

        if (!isset($headers['Content-Length'])) {
            $psrResponse = $psrResponse->withAddedHeader('Content-Length', strlen($content));
        }

        $psrResponse = $psrResponse->withBody(Psr7\stream_for($content));

        $kernel->terminate($request, $response);

        return $psrResponse;
};
$loop = React\EventLoop\Factory::create();
$http = new React\Http\Server($callback);
$socket = new React\Socket\Server(getenv('SERVERPORT') ?: 1337, $loop);
$http->listen($socket);
$loop->run();