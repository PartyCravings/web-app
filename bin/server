#!/usr/bin/env php
<?php
use AppBundle\Utils\ServerUtils;
use AppBundle\Utils\StrongerNativeSessionStorage;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Session;
use Symfony\Component\HttpFoundation\Cookie;
use Symfony\Component\HttpFoundation\StreamedResponse;
use Psr\Http\Message\ServerRequestInterface;
use RingCentral\Psr7;
use React\EventLoop\Factory;
use React\Http\Response;

require __DIR__.'/../vendor/autoload.php';
// if you don't want to setup permissions the proper way, just uncomment the following PHP line
// read https://symfony.com/doc/current/setup.html#checking-symfony-application-configuration-and-setup
// for more information
//umask(0000);
set_time_limit(0);
$kernel = new AppKernel('dev', true);
// When using the HttpCache, you need to call the method in your front controller instead of relying on the configuration parameter
Request::enableHttpMethodParameterOverride();
Request::setTrustedProxies(
    // the IP address (or range) of your proxy
    ['127.0.0.1', '10.0.0.0/8'],
    // trust *all* "X-Forwarded-*" headers
    Request::HEADER_X_FORWARDED_ALL
    // or, if your proxy instead uses the "Forwarded" header
    // Request::HEADER_FORWARDED
    // or, if you're using AWS ELB
    // Request::HEADER_X_FORWARDED_AWS_ELB
);
ServerUtils::bindAndCall(function() use ($kernel) {
        // init bundles
        $kernel->initializeBundles();
        // init container
        $kernel->initializeContainer();
    }, $kernel);
//now we can modify the container
$nativeStorage = new StrongerNativeSessionStorage(
        $kernel->getContainer()->getParameter('session.storage.options'),
        $kernel->getContainer()->has('session.handler') ? $kernel->getContainer()->get('session.handler'): null,
        $kernel->getContainer()->get('session.storage.metadata_bag')
    );
$kernel->getContainer()->set('session.storage.native', $nativeStorage);
ServerUtils::bindAndCall(function() use ($kernel) {
        foreach ($kernel->getBundles() as $bundle) {
                $bundle->setContainer($kernel->container);
                $bundle->boot();
            }
            $kernel->booted = true;
        }, $kernel);

$container = $kernel->getContainer();
$kernel = new AppCache($kernel);

$callback = function (ServerRequestInterface $request) use ($kernel) {
    $mem_usage = memory_get_peak_usage(true)/(1024*1024);
    if (55 <= $mem_usage) {
        die('MAX MEMORY EXCEEDED');
    }

    $method = $request->getMethod();
    $headers = $request->getHeaders();
    $content = $request->getParsedBody();
    $server = $request->getServerParams();
    $server['REQUEST_URI'] = (string)$request->getUri();

    $_COOKIE = $request->getCookieParams();
    $_POST =(array)$content;
    $_GET = $request->getQueryParams();
    $_FILES = $request->getUploadedFiles();
    $_SERVER = array_merge($_SERVER, $server);
    

    $request = Request::createFromGlobals();
    $request->setMethod($method);
    $request->headers->replace($headers);
    $response = $kernel->handle($request);

    $headers = $response->headers->allPreserveCase();
    // after reading all headers we need to reset it, so next request
    // operates on a clean header.
    $headers['X-Powered-By'] = 'Terminator/Genisys';
    $psrResponse = new Psr7\Response($response->getStatusCode(), $headers);

    // get contents
    ob_start();
    if ($response instanceof StreamedResponse) {
        $response->sendContent();
        $content = @ob_get_clean();
    }
    else {
        $content = $response->getContent();
        @ob_end_flush();
    }
    $psrResponse = $psrResponse->withBody(Psr7\stream_for($content));
    $kernel->terminate($request, $response);

    return $psrResponse;
};
$loop = React\EventLoop\Factory::create();
$http = new React\Http\Server($callback);
$socket = new React\Socket\Server(getenv('SERVERPORT') ?: 1337, $loop);
$http->listen($socket);
$loop->run();